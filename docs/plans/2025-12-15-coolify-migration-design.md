# Meeboter: AWS to Coolify Migration Design

**Date:** 2025-12-15
**Updated:** 2025-12-16
**Status:** Server Deployed - Bot Spawning Testing Pending
**Author:** AI-assisted design session

---

## 1. Overview & Goals

### Migration Overview

**From:** AWS-based infrastructure (ECS Fargate, RDS, S3, ECR, ALB)
**To:** Self-hosted Coolify on bare-metal server

### Goals

1. **Complete AWS independence** - No AWS services required for operation
2. **Single management plane** - All services visible and manageable in Coolify UI
3. **Cost reduction** - Eliminate AWS compute and managed service costs
4. **Full visibility** - Logs, metrics, and container status in one place
5. **Simplified deployment** - GitHub Actions → ghcr.io → Coolify webhook

### What Changes

| Area | Current (AWS) | New (Coolify) |
|------|---------------|---------------|
| Bot spawning | ECS Fargate API | Coolify REST API |
| Database | RDS PostgreSQL | Coolify PostgreSQL service |
| File storage | S3 | MinIO (S3-compatible) |
| Container registry | ECR | GitHub Container Registry |
| Load balancer | ALB | Coolify/Traefik (built-in) |
| SSL certificates | ACM | Let's Encrypt (Coolify auto) |
| Logging | CloudWatch | Coolify UI + container logs |

### What Stays the Same

- Application code structure (monorepo)
- Database schema (Drizzle ORM)
- tRPC API layer
- Bot logic and recording functionality
- S3 SDK usage (MinIO is S3-compatible)

---

## 2. Infrastructure Components

### Coolify Services Setup

#### 1. PostgreSQL (One-Click Service)

```
Service Type: PostgreSQL
Version: 17 (matching current RDS)
Storage: Persistent volume on host
Connection: Internal network (meeboter-network)
```

**Configuration:**
- Database name: `meeboter`
- Auto-generated credentials (stored in Coolify)
- Backup to MinIO (optional, Coolify supports this natively)

#### 2. MinIO (One-Click Service)

```
Service Type: MinIO
Storage: Persistent volume for recordings
Access: HTTPS required (Coolify handles SSL)
```

**Configuration:**
- Create bucket: `meeboter-recordings`
- Access/Secret keys generated by MinIO
- S3-compatible endpoint: `https://minio.yourdomain.com`

#### 3. Meeboter Server (Docker Image Application)

```
Type: Docker Image
Image: ghcr.io/payme-works/meeboter-milo:latest
Port: 3000
Domain: meeboter.yourdomain.com
```

**Deployment trigger:** Coolify webhook from GitHub Actions

#### 4. Dynamic Bot Services (Created via API)

Bots are **not** pre-deployed. They're created on-demand via Coolify API when a user requests a meeting bot:

```
Type: Docker Image (created dynamically)
Images: ghcr.io/payme-works/meeboter-{meet,teams,zoom}-bot:latest
Lifecycle: Created → Runs → Deleted after completion
```

### Network Architecture

```
┌─────────────────────────────────────────┐
│           meeboter-network              │
│                                         │
│  PostgreSQL ◄──► Server ◄──► MinIO     │
│                    │                    │
│              ┌─────┴─────┐              │
│              ▼     ▼     ▼              │
│           Bot1   Bot2   Bot3            │
└─────────────────────────────────────────┘
                    │
              Traefik (reverse proxy)
                    │
              HTTPS (Let's Encrypt)
```

---

## 3. Bot Deployment Service - Code Changes

### Current Implementation (`bot-deployment.ts`)

The current code uses AWS ECS SDK:

```typescript
// Current: AWS ECS
import { ECSClient, RunTaskCommand } from "@aws-sdk/client-ecs";

const client = new ECSClient({ region: env.AWS_REGION });
await client.send(new RunTaskCommand({
  cluster: env.ECS_CLUSTER_NAME,
  taskDefinition: env.ECS_TASK_DEFINITION_MEET,
  launchType: "FARGATE",
  // ...
}));
```

### New Implementation (Coolify API)

Replace with Coolify API calls:

```typescript
// New: Coolify API
interface CoolifyDeploymentConfig {
  coolifyApiUrl: string;      // e.g., "https://coolify.yourdomain.com/api/v1"
  coolifyApiToken: string;    // Bearer token from Coolify
  projectUuid: string;        // Coolify project UUID
  serverUuid: string;         // Coolify server UUID
  environmentName: string;    // e.g., "production"
}

async function deployBot({ botId, db }: DeployBotParams) {
  const bot = await db.select().from(botsTable).where(eq(botsTable.id, botId));
  const config = buildBotConfig(bot[0]);

  // Select image based on platform
  const image = selectBotImage(bot[0].meetingInfo);

  // Create service via Coolify API
  const response = await fetch(`${env.COOLIFY_API_URL}/applications/dockerimage`, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${env.COOLIFY_API_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      project_uuid: env.COOLIFY_PROJECT_UUID,
      server_uuid: env.COOLIFY_SERVER_UUID,
      environment_name: env.COOLIFY_ENVIRONMENT_NAME,
      docker_registry_image_name: image.name,
      docker_registry_image_tag: image.tag,
      name: `meeboter-bot-${botId}`,
      instant_deploy: true,
    }),
  });

  const { uuid } = await response.json();

  // Store Coolify service UUID for cleanup later
  await db.update(botsTable)
    .set({ coolifyServiceUuid: uuid })
    .where(eq(botsTable.id, botId));

  return uuid;
}
```

### Bot Cleanup (New Function)

When bot finishes, delete the Coolify service:

```typescript
async function cleanupBot(coolifyServiceUuid: string) {
  await fetch(`${env.COOLIFY_API_URL}/applications/${coolifyServiceUuid}`, {
    method: "DELETE",
    headers: {
      "Authorization": `Bearer ${env.COOLIFY_API_TOKEN}`,
    },
  });
}
```

### Image Selection

```typescript
function selectBotImage(meetingInfo: MeetingInfo): { name: string; tag: string } {
  const baseImage = `ghcr.io/${env.GHCR_ORG}/meeboter`;
  const tag = env.BOT_IMAGE_TAG || "latest";

  switch (meetingInfo.platform?.toLowerCase()) {
    case "google":
      return { name: `${baseImage}-google-meet-bot`, tag };
    case "teams":
      return { name: `${baseImage}-teams-bot`, tag };
    case "zoom":
      return { name: `${baseImage}-zoom-bot`, tag };
    default:
      throw new Error(`Unsupported platform: ${meetingInfo.platform}`);
  }
}
```

---

## 4. Environment Variables

### Variables to Remove (AWS-specific)

```bash
# Remove these from env.js and .env files
AWS_ACCESS_KEY_ID          # No longer needed (MinIO uses different auth)
AWS_SECRET_ACCESS_KEY      # No longer needed
AWS_REGION                 # No longer needed
AWS_BUCKET_NAME            # Replaced with MINIO_*

ECS_CLUSTER_NAME           # Replaced with Coolify API
ECS_TASK_DEFINITION_MEET   # Replaced with GHCR images
ECS_TASK_DEFINITION_TEAMS  # Replaced with GHCR images
ECS_TASK_DEFINITION_ZOOM   # Replaced with GHCR images
ECS_SUBNETS                # Not needed (Coolify manages networking)
ECS_SECURITY_GROUPS        # Not needed
```

### New Variables (Coolify + MinIO)

```bash
# Coolify API Configuration
COOLIFY_API_URL=https://coolify.yourdomain.com/api/v1
COOLIFY_API_TOKEN=your-coolify-api-token
COOLIFY_PROJECT_UUID=project-uuid-from-coolify
COOLIFY_SERVER_UUID=server-uuid-from-coolify
COOLIFY_ENVIRONMENT_NAME=production
COOLIFY_DESTINATION_UUID=destination-uuid-from-coolify

# GitHub Container Registry
GHCR_ORG=your-github-org-or-username
BOT_IMAGE_TAG=latest

# MinIO Configuration (S3-compatible)
MINIO_ENDPOINT=https://minio.yourdomain.com
MINIO_ACCESS_KEY=your-minio-access-key
MINIO_SECRET_KEY=your-minio-secret-key
MINIO_BUCKET_NAME=meeboter-recordings
MINIO_REGION=us-east-1  # MinIO accepts any region string

# Keep these unchanged
DATABASE_URL=postgresql://user:pass@postgres:5432/meeboter
AUTH_SECRET=...
AUTH_GITHUB_ID=...
AUTH_GITHUB_SECRET=...
BOT_AUTH_TOKEN=...
NEXT_PUBLIC_APP_ORIGIN_URL=https://meeboter.yourdomain.com
```

### Updated `env.js` Schema

```javascript
server: {
  // ... keep AUTH_*, DATABASE_URL, NODE_ENV

  // Coolify
  COOLIFY_API_URL: z.string().url(),
  COOLIFY_API_TOKEN: z.string(),
  COOLIFY_PROJECT_UUID: z.string(),
  COOLIFY_SERVER_UUID: z.string(),
  COOLIFY_ENVIRONMENT_NAME: z.string().default("production"),
  COOLIFY_DESTINATION_UUID: z.string(),

  // GHCR
  GHCR_ORG: z.string(),
  BOT_IMAGE_TAG: z.string().default("latest"),

  // MinIO (S3-compatible)
  MINIO_ENDPOINT: z.string().url(),
  MINIO_ACCESS_KEY: z.string(),
  MINIO_SECRET_KEY: z.string(),
  MINIO_BUCKET_NAME: z.string(),
  MINIO_REGION: z.string().default("us-east-1"),

  // Keep
  BOT_AUTH_TOKEN: z.string().optional(),
  NEXT_PUBLIC_APP_ORIGIN_URL: z.string().url(),
}
```

### Bot Container Environment Variables

When spawning bots via Coolify API, inject these:

```bash
BOT_DATA={"id":123,"meetingInfo":...}  # JSON config
BOT_AUTH_TOKEN=...                      # Auth with server
BACKEND_URL=https://meeboter.yourdomain.com/api/trpc
MINIO_ENDPOINT=https://minio.yourdomain.com
MINIO_ACCESS_KEY=...
MINIO_SECRET_KEY=...
MINIO_BUCKET_NAME=meeboter-recordings
NODE_ENV=production
```

---

## 5. GitHub Actions CI/CD

### Workflow File: `.github/workflows/deploy.yml`

```yaml
name: Build and Deploy to Coolify

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/meeboter

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        include:
          - name: server
            dockerfile: apps/server/Dockerfile
            context: .
          - name: meet-bot
            dockerfile: apps/bots/providers/meet/Dockerfile
            context: .
          - name: teams-bot
            dockerfile: apps/bots/providers/teams/Dockerfile
            context: .
          - name: zoom-bot
            dockerfile: apps/bots/providers/zoom/Dockerfile
            context: .

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.name }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Trigger Coolify Deployment
        run: |
          curl --request GET "${{ secrets.COOLIFY_WEBHOOK }}" \
            --header "Authorization: Bearer ${{ secrets.COOLIFY_TOKEN }}"
```

### Required GitHub Secrets

| Secret | Description |
|--------|-------------|
| `COOLIFY_WEBHOOK` | Webhook URL from Coolify server app |
| `COOLIFY_TOKEN` | API token from Coolify dashboard |

**Note:** `GITHUB_TOKEN` is automatically provided by GitHub Actions for ghcr.io authentication.

### Image Tags Strategy

Each push creates two tags:
- `latest` - Always points to newest build
- `sha-abc1234` - Git commit SHA for rollbacks

### Resulting Images

After workflow runs:
```
ghcr.io/payme-works/meeboter-milo:latest
ghcr.io/payme-works/meeboter-milo:sha-abc1234
ghcr.io/payme-works/meeboter-google-meet-bot:latest
ghcr.io/payme-works/meeboter-teams-bot:latest
ghcr.io/payme-works/meeboter-zoom-bot:latest
```

---

## 6. MinIO/S3 Configuration

### Why This Works With Zero Code Changes

MinIO implements the S3 API specification. The `@aws-sdk/client-s3` library works with any S3-compatible endpoint - you just change the configuration.

### Updated `s3.ts` (Server)

```typescript
import { GetObjectCommand, PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { env } from "@/env";

let s3ClientInstance: S3Client | null = null;

const getS3Client = (): S3Client => {
  s3ClientInstance ??= new S3Client({
    endpoint: env.MINIO_ENDPOINT,           // MinIO endpoint
    region: env.MINIO_REGION,               // Can be any string
    credentials: {
      accessKeyId: env.MINIO_ACCESS_KEY,
      secretAccessKey: env.MINIO_SECRET_KEY,
    },
    forcePathStyle: true,  // Required for MinIO
  });

  return s3ClientInstance;
};

const s3Client = getS3Client();

export const generateSignedUrl = async (
  key: string,
  expiresIn = 3600,
): Promise<string> => {
  const command = new GetObjectCommand({
    Bucket: env.MINIO_BUCKET_NAME,
    Key: key,
  });

  return await getSignedUrl(s3Client, command, { expiresIn });
};
```

> **Important:** `forcePathStyle: true` is crucial for MinIO. AWS S3 uses virtual-hosted style (`bucket.s3.amazonaws.com`), while MinIO uses path style (`minio.domain.com/bucket`).

### Bot S3 Upload (Existing Pattern)

The bot upload code in `apps/bots/` already uses the S3 SDK. Same change applies:

```typescript
// In bot's upload code
const s3Client = new S3Client({
  endpoint: process.env.MINIO_ENDPOINT,
  region: process.env.MINIO_REGION,
  credentials: {
    accessKeyId: process.env.MINIO_ACCESS_KEY,
    secretAccessKey: process.env.MINIO_SECRET_KEY,
  },
  forcePathStyle: true,
});

// Upload recording - unchanged
await s3Client.send(new PutObjectCommand({
  Bucket: process.env.MINIO_BUCKET_NAME,
  Key: `recordings/${botId}/${filename}`,
  Body: recordingBuffer,
  ContentType: "video/webm",
}));
```

### MinIO Setup in Coolify

1. Deploy MinIO one-click service
2. Set domain: `minio.yourdomain.com`
3. Wait for SSL certificate (Coolify auto-provisions)
4. Access MinIO Console (usually port 9001)
5. Create bucket: `meeboter-recordings`
6. Create access key pair
7. Set bucket policy (if public read needed):

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": "*",
      "Action": ["s3:GetObject"],
      "Resource": ["arn:aws:s3:::meeboter-recordings/*"]
    }
  ]
}
```

### Storage Considerations

| Aspect | AWS S3 | MinIO |
|--------|--------|-------|
| Capacity | Unlimited | Limited by disk |
| Redundancy | Built-in | Single node (add drives for redundancy) |
| Cost | Pay per GB | Free (your storage) |
| Backup | Cross-region | Manual or to external S3 |

---

## 7. Database Schema Changes

### New Column: `coolifyServiceUuid`

We need to store the Coolify service UUID so we can clean up the bot service when it finishes.

### Migration (Drizzle Schema)

Update `apps/server/src/server/database/schema.ts`:

```typescript
export const botsTable = pgTable("bots", {
  id: serial("id").primaryKey(),
  userId: text("user_id").notNull(),

  // ... existing columns ...

  status: statusEnum("status").notNull().default("CREATED"),
  deploymentError: text("deployment_error"),

  // NEW: Store Coolify service UUID for cleanup
  coolifyServiceUuid: text("coolify_service_uuid"),

  // ... rest of columns ...

  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
```

### Why This Is Needed

```
Bot Lifecycle with Coolify:

1. User requests bot
2. Server creates bot record in DB
3. Server calls Coolify API → gets service UUID
4. Store UUID in coolifyServiceUuid column     ← NEW
5. Bot runs, joins meeting, records
6. Bot finishes, calls updateBotStatus(DONE)
7. Server calls Coolify API to DELETE service  ← Uses stored UUID
8. Bot container removed, resources freed
```

### Updated Bot Status Handler

In `bots.ts` router, add cleanup on completion:

```typescript
updateBotStatus: publicProcedure
  .mutation(async ({ input, ctx }) => {
    // ... existing logic ...

    // When bot completes, clean up Coolify service
    if (input.status === "DONE" || input.status === "FATAL") {
      const bot = await ctx.db
        .select({ coolifyServiceUuid: botsTable.coolifyServiceUuid })
        .from(botsTable)
        .where(eq(botsTable.id, input.id))
        .limit(1);

      if (bot[0]?.coolifyServiceUuid) {
        // Fire and forget - don't block the response
        cleanupCoolifyService(bot[0].coolifyServiceUuid).catch((error) => {
          console.error(`Failed to cleanup Coolify service: ${error.message}`);
        });
      }
    }

    // ... rest of existing logic ...
  }),
```

### Cleanup Function

```typescript
async function cleanupCoolifyService(serviceUuid: string): Promise<void> {
  const response = await fetch(
    `${env.COOLIFY_API_URL}/applications/${serviceUuid}`,
    {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${env.COOLIFY_API_TOKEN}`,
      },
    }
  );

  if (!response.ok) {
    throw new Error(`Coolify delete failed: ${response.status}`);
  }

  console.log(`Cleaned up Coolify service: ${serviceUuid}`);
}
```

### Migration Command

After updating schema:

```bash
# Generate migration (when user requests)
bun db:generate

# Apply migration (when user requests)
bun db:migrate
```

---

## 8. Coolify Setup Steps

### Prerequisites

- Coolify installed on your bare-metal server
- Domain pointing to your server (e.g., `meeboter.yourdomain.com`)
- GitHub account with repository access

### Step-by-Step Setup

#### 1. Configure GitHub Container Registry Access

Coolify doesn't have a UI for Docker registries. SSH into the server and login directly:

```bash
# SSH into your Coolify server
ssh user@your-server

# Create a GitHub PAT with read:packages scope, then login
echo "YOUR_GITHUB_PAT" | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin
```

Once logged in, Coolify automatically detects and uses these credentials when pulling images.

#### 2. Create Project in Coolify

1. Go to Coolify Dashboard → **Projects** → **New Project**
2. Name: `meeboter`
3. Create environment: `production`

#### 3. Deploy PostgreSQL

1. In project → **New Resource** → **Service** → **PostgreSQL**
2. Configure:
   - Version: `17`
   - Database name: `meeboter`
   - Generate password (save it)
3. Deploy and wait for healthy status
4. Note the internal connection string:
   ```
   postgresql://postgres:PASSWORD@PROJECT_UUID-postgresql:5432/meeboter
   ```

#### 4. Deploy MinIO

1. **New Resource** → **Service** → **MinIO**
2. Configure:
   - Domain: `minio.yourdomain.com` (API)
   - Console domain: `minio-console.yourdomain.com` (optional)
3. Deploy and wait for healthy status
4. Access console, create:
   - Bucket: `meeboter-recordings`
   - Access Key + Secret Key (save these)

#### 5. Deploy Meeboter Server

1. **New Resource** → **Application** → **Docker Image**
2. Configure:
   - Image: `ghcr.io/payme-works/meeboter-milo:latest`
   - Port: `3000`
   - Domain: `meeboter.yourdomain.com`
3. Add environment variables (from Section 4)
4. Go to **Webhooks** tab → copy webhook URL
5. Deploy

#### 6. Get UUIDs for Bot Spawning

You need these UUIDs for the server's environment variables:

| UUID | Where to find |
|------|---------------|
| `COOLIFY_PROJECT_UUID` | URL when viewing project: `/project/THIS-UUID` |
| `COOLIFY_SERVER_UUID` | Settings → Servers → click server → URL |
| `COOLIFY_DESTINATION_UUID` | Server → Destinations → select Docker → URL |

#### 7. Create API Token

1. Coolify Dashboard → **Settings** → **Keys & Tokens** → **API tokens**
2. Click **Add** and create new token with description: `meeboter-bot-spawning`
3. Copy token → save as `COOLIFY_API_TOKEN`

#### 8. Configure GitHub Secrets

In your GitHub repository → Settings → Secrets:

| Secret | Value |
|--------|-------|
| `COOLIFY_WEBHOOK` | Webhook URL from step 5 |
| `COOLIFY_TOKEN` | API token from step 7 |

#### 9. Test Deployment

```bash
# Push to trigger GitHub Actions
git push origin main

# Or manually trigger
gh workflow run deploy.yml
```

---

## 9. Migration Checklist

### Pre-Migration

- [ ] Backup existing AWS RDS database
- [ ] Export existing S3 recordings (if needed)
- [ ] Document current environment variables
- [ ] Ensure Coolify is installed and accessible
- [ ] Domain DNS configured pointing to Coolify server

### Code Changes

- [x] Update `apps/server/src/env.js` - new environment variable schema
- [x] Create `apps/server/src/server/api/services/coolify-deployment.ts` - new deployment service
- [x] Update `apps/server/src/server/api/services/bot-deployment.ts` - use Coolify instead of ECS
- [x] Update `apps/server/src/server/utils/s3.ts` - MinIO configuration
- [x] Update `apps/server/src/server/database/schema.ts` - add `coolifyServiceUuid` column
- [x] Update `apps/server/src/server/api/routers/bots.ts` - add cleanup on bot completion
- [x] Update bot apps S3 configuration (meet, teams, zoom)
- [ ] Remove AWS ECS SDK dependencies (optional cleanup)

### GitHub Setup

- [x] Create `.github/workflows/deploy.yml`
- [x] Create GitHub PAT with `read:packages` and `write:packages` scope
- [ ] Add `COOLIFY_WEBHOOK` secret to repository (optional - can use Coolify UI)
- [ ] Add `COOLIFY_TOKEN` secret to repository (optional - can use Coolify UI)

### Coolify Setup

- [x] Create `meeboter` project with `production` environment
- [x] Deploy PostgreSQL one-click service
- [x] Deploy MinIO one-click service
- [x] Create MinIO bucket (`meeboter`)
- [x] Create MinIO access credentials (using root credentials)
- [x] Deploy Meeboter Server as Docker Image application
- [x] Configure all environment variables in Coolify
- [x] Login to ghcr.io on Coolify server
- [x] Create Coolify API token
- [x] Note all required UUIDs (project, server, destination)

### Database Migration

- [ ] Generate Drizzle migration for `coolifyServiceUuid` column
- [ ] Run migration against new PostgreSQL instance
- [ ] Migrate data from AWS RDS (if applicable)

### Testing

- [x] Verify server deploys and starts correctly
- [x] Test GitHub Actions workflow triggers deployment
- [ ] Test bot spawning via Coolify API
- [ ] Test recording upload to MinIO
- [ ] Test signed URL generation for recordings
- [ ] Test bot cleanup after completion
- [ ] Verify all bots visible in Coolify UI

### Post-Migration

- [ ] Monitor for 24-48 hours
- [ ] Decommission AWS resources (ECS, RDS, S3)
- [ ] Update documentation
- [ ] Remove old Terraform configuration (optional)

---

## 10. Next Steps (Post-Implementation)

The code implementation is complete. Follow these steps to complete the migration:

### Step 1: Generate Database Migration

```bash
# Generate migration for the new coolifyServiceUuid column
bun drizzle-kit generate

# Apply migration to your database
bun drizzle-kit migrate
```

### Step 2: Set Up MinIO in Coolify

#### 2.1 Deploy MinIO Service

1. Go to Coolify Dashboard → **Projects** → Your Project → **New Resource**
2. Select **Service** → **MinIO**
3. Configure:
   - **Domain (API)**: `minio.yourdomain.com` (port 9000)
   - **Console Domain**: `minio-console.yourdomain.com` (port 9001, optional)
4. Deploy and wait for healthy status

#### 2.2 Get Root Credentials

After deployment, find the auto-generated root credentials:

1. In Coolify, go to your MinIO service
2. Click **Environment Variables** or **Secrets** tab
3. Find and copy:
   - `MINIO_ROOT_USER` (or `MINIO_ACCESS_KEY`)
   - `MINIO_ROOT_PASSWORD` (or `MINIO_SECRET_KEY`)

#### 2.3 Access MinIO Console

1. Open the MinIO Console URL (port 9001):
   - Via domain: `https://minio-console.yourdomain.com`
   - Or direct: `http://your-server-ip:9001`
2. Login with root credentials from step 2.2

#### 2.4 Create Dedicated Access Keys (Recommended)

Instead of using root credentials in your app, create dedicated access keys:

1. In MinIO Console, navigate to: **Access Keys** (left sidebar)
2. Click **Create Access Key**
3. **Important:** Copy both values immediately (secret is shown only once!)
   - **Access Key**: e.g., `minio_meeboter_abc123`
   - **Secret Key**: e.g., `minio_secret_xyz789...`

#### 2.5 Create the Recordings Bucket

1. In MinIO Console, go to **Buckets** (left sidebar)
2. Click **Create Bucket**
3. Bucket name: `meeboter-recordings`
4. Click **Create Bucket**

#### 2.6 MinIO Environment Variables Summary

```bash
# S3 API endpoint (NOT the console URL)
# Use internal hostname if on same Coolify network:
MINIO_ENDPOINT=http://minio-service-name:9000
# Or external URL if accessible via domain:
MINIO_ENDPOINT=https://minio.yourdomain.com

# Credentials (from step 2.4)
MINIO_ACCESS_KEY=your-access-key
MINIO_SECRET_KEY=your-secret-key

# Bucket name
MINIO_BUCKET_NAME=meeboter-recordings

# Region (MinIO ignores this, but AWS SDK requires it)
MINIO_REGION=us-east-1
```

> **Note:** `MINIO_REGION` can be any string. MinIO doesn't use regions like AWS S3 - it's only required because the AWS S3 SDK needs a region parameter.

### Step 3: Configure GHCR Registry Access on Coolify Server

Coolify doesn't have a UI for Docker registries. Instead, you SSH into the server and login directly.

**For Organization Repositories (Payme-Works/meeboter):**

#### 3.1 Create a GitHub Personal Access Token (PAT)

**Recommended: Use Classic Token** (simpler for GHCR):

1. Go to: **https://github.com/settings/tokens/new**
   - Or: GitHub → Avatar → Settings → Developer settings → Personal access tokens → Tokens (classic) → Generate new token
2. Configure:
   - **Note**: `coolify-ghcr-access`
   - **Expiration**: Choose appropriate duration (or no expiration)
   - **Select scopes**:
     - ✅ `read:packages` - Download packages from GHCR
     - ✅ `write:packages` - (optional, only if pushing from server)
3. Click **"Generate token"** and copy it immediately

**Alternative (Fine-grained Token):**
1. Go to: https://github.com/settings/tokens?type=beta
2. Resource owner: `Payme-Works`
3. Repository access: Select repositories
4. Under **"Repositories"** tab (not Organizations) → **"Packages"** → Read

#### 3.2 Verify Package Access (after first push)

When packages are pushed via GitHub Actions using `GITHUB_TOKEN`, they are **automatically linked** to the source repository. You can verify this:

1. Go to: **https://github.com/orgs/Payme-Works/packages**
2. Click on any package (e.g., `meeboter-milo`)
3. Look for **"Linked to Payme-Works/meeboter"** in the package details

**If packages are NOT linked** (rare, only if pushed manually):
1. Click **"Package settings"** (gear icon or right side)
2. Under **"Repository access"** or **"Manage Actions access"** → Add `Payme-Works/meeboter` repository with read access

#### 3.3 Login on Coolify Server

```bash
# SSH into your Coolify server
ssh user@your-coolify-server

# Login to GHCR (use your GitHub username, not org name)
echo "YOUR_GITHUB_PAT" | docker login ghcr.io -u YOUR_GITHUB_USERNAME --password-stdin

# Verify login succeeded
cat ~/.docker/config.json | grep ghcr
```

Once logged in, Coolify automatically detects and uses these credentials when pulling images.

**Image paths for this project:**
```
ghcr.io/payme-works/meeboter-milo:latest
ghcr.io/payme-works/meeboter-google-meet-bot:latest
ghcr.io/payme-works/meeboter-teams-bot:latest
ghcr.io/payme-works/meeboter-zoom-bot:latest
```

**Environment variable:** `GHCR_ORG=payme-works` (lowercase)

**Alternative Method:** Connect a GitHub App in Coolify's **Sources** section, which allows pulling from ghcr.io without explicit docker login.

### Step 4: Collect Coolify UUIDs

Navigate to these locations in Coolify (replace `coolify.yourdomain.com` with your actual Coolify URL):

#### 4.1 API URL
- **Value**: `https://coolify.yourdomain.com/api/v1`
- Just append `/api/v1` to your Coolify dashboard URL

#### 4.2 API Token
- **Navigate to**: `https://coolify.yourdomain.com/settings/tokens`
- Or: Coolify Dashboard → Settings (gear icon, bottom left) → Keys & Tokens → API tokens
- Click **"Add"** → Give it a name like `meeboter-bot-spawning` → Copy the token

= 2|r98UrbnzXJjEpbZljw2ECWINkwgooX1IRegAMUer15f936d0

#### 4.3 Project UUID
- **Navigate to**: `https://coolify.yourdomain.com/projects`
- Click on your project (e.g., "meeboter")
- Look at the URL: `https://coolify.yourdomain.com/project/abc12345-...`
- Copy the UUID after `/project/` 

#### 4.4 Server UUID
- **Navigate to**: `https://coolify.yourdomain.com/servers`
- Or: Settings → Servers
- Click on your server
- Look at the URL: `https://coolify.yourdomain.com/server/def67890-...`
- Copy the UUID after `/server/`

= /project/c4s84os8csko8c0o4s0coo88/environment/a8c4og80sswswgc8o4wocoko/application/bwoc44o48kcwcgwcg4kog84k

#### 4.5 Destination UUID
- **Navigate to**: Your server page → Destinations tab
- Or from server URL, add `/destinations`
- Click on the Docker destination (usually "Local Docker Engine")
- Look at the URL: `https://coolify.yourdomain.com/destination/ghi11111-...`
- Copy the UUID after `/destination/`

= osko4k8g4ko0cw84ws4wokks

| Variable | Example Value |
|----------|---------------|
| `COOLIFY_API_URL` | `https://coolify.yourdomain.com/api/v1` |
| `COOLIFY_API_TOKEN` | `1|abc123...` (generated token) |
| `COOLIFY_PROJECT_UUID` | `abc12345-1234-5678-9012-abcdef123456` |
| `COOLIFY_SERVER_UUID` | `def67890-1234-5678-9012-abcdef123456` |
| `COOLIFY_DESTINATION_UUID` | `ghi11111-1234-5678-9012-abcdef123456` |

### Step 5: Deploy Meeboter Server Application

1. In Coolify: **New Resource** → **Application** → **Docker Image**
2. Configure:
   - **Image**: `ghcr.io/payme-works/meeboter-milo:latest`
   - **Port**: `3000`
   - **Domain**: `meeboter.yourdomain.com`
3. Add all environment variables:

```bash
# Database
DATABASE_URL=postgresql://user:pass@postgres-service:5432/meeboter

# Auth
AUTH_SECRET=your-auth-secret
AUTH_GITHUB_ID=your-github-oauth-id
AUTH_GITHUB_SECRET=your-github-oauth-secret

# Coolify (for bot spawning)
COOLIFY_API_URL=https://coolify.yourdomain.com/api/v1
COOLIFY_API_TOKEN=your-coolify-api-token
COOLIFY_PROJECT_UUID=your-project-uuid
COOLIFY_SERVER_UUID=your-server-uuid
COOLIFY_DESTINATION_UUID=your-destination-uuid
COOLIFY_ENVIRONMENT_NAME=production

# GHCR (for bot images)
GHCR_ORG=payme-works
BOT_IMAGE_TAG=latest

# MinIO
MINIO_ENDPOINT=http://minio-service:9000
MINIO_ACCESS_KEY=your-minio-access-key
MINIO_SECRET_KEY=your-minio-secret-key
MINIO_BUCKET_NAME=meeboter-recordings
MINIO_REGION=us-east-1

# App
NEXT_PUBLIC_APP_ORIGIN_URL=https://meeboter.yourdomain.com
NODE_ENV=production
```

4. Deploy the application
5. After deployment, go to the application → **Webhooks** menu → Copy the webhook URL (for GitHub Actions)

### Step 6: Configure GitHub Repository

#### 6.1 Enable Packages Write Permission

1. Go to: **https://github.com/Payme-Works/meeboter/settings/actions**
2. Scroll down to **"Workflow permissions"**
3. Select **"Read and write permissions"**
4. Click **"Save"**

#### 6.2 (Optional) Add Coolify Webhook for Auto-Deploy

1. Go to: **https://github.com/Payme-Works/meeboter/settings/variables/actions**
   - Or: Repository → Settings → Secrets and variables → Actions → Variables tab
2. Click **"New repository variable"**
3. Add:
   - **Name**: `COOLIFY_WEBHOOK_URL`
   - **Value**: The webhook URL from Step 5 (from your deployed application's Webhooks menu)

### Step 7: First Deployment

```bash
# Commit all changes
git add .
git commit -m "Migrate to Coolify infrastructure"
git push origin main
```

Monitor the GitHub Actions workflow at: **https://github.com/Payme-Works/meeboter/actions**

### Step 8: Verification

After deployment, verify:

- [ ] **GitHub Actions completed**: https://github.com/Payme-Works/meeboter/actions
- [ ] **Server application is healthy** in Coolify dashboard
- [ ] **All 4 images published to GHCR**: https://github.com/orgs/Payme-Works/packages
  - `ghcr.io/payme-works/meeboter-milo`
  - `ghcr.io/payme-works/meeboter-google-meet-bot`
  - `ghcr.io/payme-works/meeboter-teams-bot`
  - `ghcr.io/payme-works/meeboter-zoom-bot`
- [ ] **Create a test bot** → verify it appears in Coolify UI as a new application
- [ ] **Bot completes** → verify Coolify service is automatically deleted
- [ ] **Recording uploads** to MinIO successfully (check MinIO console)
- [ ] **Signed URLs work** for recording playback

### Step 9: Decommission AWS (After Verification)

Once everything is verified working for 24-48 hours:

1. Stop ECS services
2. Export any remaining S3 data
3. Delete RDS instance (after final backup)
4. Remove Terraform resources or manually delete AWS infrastructure
5. Revoke AWS credentials

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────────┐
│                           GitHub                                     │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                 meeboter Repository                             │ │
│  │                          │                                      │ │
│  │                   GitHub Actions                                │ │
│  │              (build ALL images & push)                          │ │
│  │                          │                                      │ │
│  └──────────────────────────┼─────────────────────────────────────┘ │
│                             ▼                                        │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │              ghcr.io (Private Registry)                         │ │
│  │                                                                 │ │
│  │  - ghcr.io/payme-works/meeboter-milo:latest                  │ │
│  │  - ghcr.io/payme-works/meeboter-google-meet-bot:latest                │ │
│  │  - ghcr.io/payme-works/meeboter-teams-bot:latest               │ │
│  │  - ghcr.io/payme-works/meeboter-zoom-bot:latest                │ │
│  │                                                                 │ │
│  └────────────────────────────┬───────────────────────────────────┘ │
└───────────────────────────────┼─────────────────────────────────────┘
                                │ pull all images
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Coolify (Bare Metal Server)                       │
│                                                                      │
│  ┌─────────────────┐  ┌─────────────────┐                           │
│  │   PostgreSQL    │  │     MinIO       │                           │
│  │   (one-click)   │  │   (one-click)   │                           │
│  └────────┬────────┘  └────────┬────────┘                           │
│           │                    │                                     │
│  ┌────────┴────────────────────┴──────────────────────────────────┐ │
│  │                   Meeboter Server                               │ │
│  │          (ghcr.io/your-org/meeboter-milo:latest)             │ │
│  │                          │                                      │ │
│  │              Coolify API │ (spawn bots)                         │ │
│  │                          ▼                                      │ │
│  └─────────────────────────────────────────────────────────────────┘ │
│                                                                      │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐                        │
│  │ Meet Bot  │  │ Teams Bot │  │ Zoom Bot  │  (pulled from ghcr.io) │
│  └───────────┘  └───────────┘  └───────────┘                        │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 11. Troubleshooting Guide

Issues encountered during deployment and their solutions:

### Docker Build Issues

#### `latest` tag not being pushed to GHCR

**Symptom:** Only SHA tags like `sha-abc123` are pushed, not `latest`.

**Cause:** The metadata-action uses `enable={{is_default_branch}}` which only applies `latest` when pushing to the repository's default branch (usually `main`).

**Solution:** Remove the condition to always push `latest`:
```yaml
# Before
type=raw,value=latest,enable={{is_default_branch}}

# After
type=raw,value=latest
```

#### Puppeteer download failing during `bun install`

**Symptom:** Error "Failed to set up chrome-headless-shell" during Docker build.

**Cause:** Puppeteer tries to download Chrome during `npm/bun install` postinstall script.

**Solution:** Add `PUPPETEER_SKIP_DOWNLOAD=true` before `bun install` in Dockerfiles:
```dockerfile
ENV PUPPETEER_SKIP_DOWNLOAD=true
RUN bun install
```

#### Turbo not passing environment variables

**Symptom:** `SKIP_ENV_VALIDATION` set in Dockerfile but Next.js still validates env vars.

**Cause:** Turbo isolates environment variables by default for caching consistency.

**Solution:** Add `passThroughEnv` to `turbo.json`:
```json
{
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "passThroughEnv": ["SKIP_ENV_VALIDATION"]
    }
  }
}
```

#### Workspace dependency not found

**Symptom:** `error: Workspace dependency "@meeboter/server" not found` during bot Docker builds.

**Cause:** Bot Dockerfiles copy `apps/bots/` and `packages/` but not `apps/server/` which is a workspace dependency.

**Solution:** Add the server package to bot Dockerfiles:
```dockerfile
COPY ./apps/bots/ ./apps/bots/
COPY ./apps/server/ ./apps/server/  # Add this line
COPY ./packages/ ./packages/
```

### Runtime Issues

#### 502 Bad Gateway after deployment

**Symptom:** Application shows "Running" in Coolify but returns 502 error.

**Diagnosis steps:**
1. Check container logs: `docker logs CONTAINER_ID`
2. Check if process is listening: `docker exec CONTAINER_ID netstat -tlnp`
3. Test internal connectivity: `curl http://CONTAINER_IP:3000`

**Common causes and solutions:**

1. **Next.js binding to IPv6 only**
   - Symptom: `netstat` shows listening on `:::3000` (IPv6) but not `0.0.0.0:3000` (IPv4)
   - Solution: Add `HOSTNAME=0.0.0.0` to Dockerfile:
     ```dockerfile
     ENV HOSTNAME=0.0.0.0
     ```

2. **Health check failing**
   - Symptom: Status shows "Running (unknown)"
   - Solution: Disable health check or set correct path/port

3. **SSL certificate provisioning failing**
   - Symptom: ACME challenge returns 502 in Traefik logs
   - Solution: Fix the underlying routing issue first, then restart Traefik

#### DATABASE_URL validation failing

**Symptom:** `Invalid string: must start with "postgresql://"` but URL starts with `postgres://`.

**Cause:** Coolify's PostgreSQL uses `postgres://` prefix (older but valid format).

**Solution:** Update env.js validation to accept both:
```javascript
DATABASE_URL: z.string().regex(/^postgres(ql)?:\/\//, {
  message: "DATABASE_URL must start with postgresql:// or postgres://",
}),
```

#### OAuth redirect_uri mismatch

**Symptom:** GitHub OAuth fails with "redirect_uri is not associated with this application" error. The redirect URI shows `https://0.0.0.0:3000` instead of the actual domain.

**Cause:** When running behind a reverse proxy (Traefik), the authentication library doesn't know the public URL. It derives the callback URL from the server's internal hostname (`0.0.0.0`) instead of the public domain.

**Solution:** Add `baseURL` to the better-auth configuration in `apps/server/src/server/auth.ts`:
```typescript
export const auth = betterAuth({
  baseURL: env.NEXT_PUBLIC_APP_ORIGIN_URL,  // Add this line
  // ... rest of config
});
```

Then ensure `NEXT_PUBLIC_APP_ORIGIN_URL` is set correctly in Coolify environment variables (e.g., `https://meeboter.HOSTNAME_PLACEHOLDER`).

### Debugging Commands

```bash
# Check container status
docker ps -a | grep meeboter

# View container logs
docker logs CONTAINER_ID --tail 100

# Check what's listening inside container
docker exec CONTAINER_ID netstat -tlnp

# Test internal connectivity
docker inspect CONTAINER_ID --format '{{.NetworkSettings.Networks.coolify.IPAddress}}'
curl http://CONTAINER_IP:3000

# Check Traefik logs
docker logs $(docker ps -q -f name=coolify-proxy) --tail 50

# Verify container is on coolify network
docker network inspect coolify | grep -A5 meeboter

# Check Traefik labels on container
docker inspect CONTAINER_ID --format '{{json .Config.Labels}}' | jq
```

---

## References

- [Coolify Documentation](https://coolify.io/docs/)
- [Coolify API Reference](https://coolify.io/docs/api-reference/api/)
- [Coolify Create Docker Image Application API](https://coolify.io/docs/api-reference/api/operations/create-dockerimage-application)
- [Coolify Delete Service API](https://coolify.io/docs/api-reference/api/operations/delete-service-by-uuid)
- [MinIO Documentation](https://min.io/docs/minio/linux/index.html)
- [GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry)
